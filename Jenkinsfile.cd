pipeline {
  agent any
  options {
    timestamps()               // Ghi log k√®m th·ªùi gian
    timeout(time: 30, unit: 'MINUTES')  // Tr√°nh treo v√¥ h·∫°n
  }

  parameters {
    string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'Docker tag c·∫ßn deploy')
  }

  environment {
    TF_DIR       = 'terraform'
    ANS_DIR      = 'ansible'
    DOCKER_IMAGE = 'nzhuy1404/lab01cuakt'
    AWS_REGION   = 'ap-southeast-1'   // ƒê·ªïi n·∫øu b·∫°n d√πng region kh√°c
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

        stage('Terraform init/plan/apply') {
        steps {
            dir('terraform') {
            sh '''#!/bin/bash
        set -euxo pipefail

        export TF_INPUT=0
        export TF_IN_AUTOMATION=1
        export AWS_DEFAULT_REGION=${AWS_REGION:-ap-southeast-1}
        export TF_LOG=INFO
        export TF_LOG_PATH=terraform.log

        echo "===> Clean local cache to avoid stale locks"
        rm -rf .terraform/ .terraform.lock.hcl || true

        echo "===> terraform init (reconfigure)"
        terraform init -no-color -input=false -reconfigure

        echo "===> terraform fmt (optional)"
        terraform fmt -check -recursive || true

        echo "===> terraform validate (with timeout 60s)"
        if ! timeout 60s bash -lc 'terraform validate -no-color'; then
        echo "WARN: terraform validate timed out or failed ‚Äî skipping validate, continuing to plan..."
        fi

        echo "===> terraform plan"
        terraform plan -no-color -input=false -out=tfplan | tee plan.out

        echo "===> terraform apply"
        terraform apply -no-color -input=false -auto-approve tfplan | tee apply.out

        echo "===> terraform output"
        terraform output -raw fe_public_ip | tee ../fe_ip.out
        '''
            }
            script {
            env.FE_IP = sh(script: 'cat terraform/fe_ip.out', returnStdout: true).trim()
            echo "New EC2 IP: ${env.FE_IP}"
            }
        }
        }


    stage('Ansible deploy FE') {
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh',
                                           keyFileVariable: 'SSH_KEY',
                                           usernameVariable: 'SSH_USER')]) {
          dir("${ANS_DIR}") {
            sh """
              set -euxo pipefail
              ANSIBLE_HOST_KEY_CHECKING=False \
              ansible-playbook -i "${FE_IP}," \
                -u ${SSH_USER} --private-key "$SSH_KEY" \
                -e docker_image=${DOCKER_IMAGE} \
                -e image_tag=${IMAGE_TAG} \
                -e app_port=8080 \
                playbook.yml
            """
          }
        }
      }
    }
  }

  post {
    success {
      echo "‚úÖ App deployed successfully: http://${FE_IP}:8080"
    }
    failure {
      echo "‚ùå Pipeline failed. Check logs for details."
    }
    always {
      echo "üìú Build finished at: ${new Date()}"
    }
  }
}
